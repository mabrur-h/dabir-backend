

// ============================================
// SUBSCRIPTION PLANS
// ============================================
export const subscriptionPlans = pgTable(
  'subscription_plans',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    name: varchar('name', { length: 50 }).notNull().unique(), // 'free', 'starter', 'pro', 'business'
    displayName: varchar('display_name', { length: 100 }).notNull(),
    displayNameUz: varchar('display_name_uz', { length: 100 }),
    priceUzs: integer('price_uzs').notNull().default(0),
    minutesPerMonth: integer('minutes_per_month').notNull(),
    description: text('description'),
    descriptionUz: text('description_uz'),
    features: jsonb('features').$type<string[]>(),
    featuresUz: jsonb('features_uz').$type<string[]>(),
    isActive: boolean('is_active').default(true).notNull(),
    sortOrder: integer('sort_order').default(0).notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => ({
    nameIdx: uniqueIndex('subscription_plans_name_idx').on(table.name),
    activeIdx: index('subscription_plans_active_idx').on(table.isActive),
  })
);

// ============================================
// MINUTE PACKAGES (Additional purchases)
// ============================================
export const minutePackages = pgTable(
  'minute_packages',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    name: varchar('name', { length: 50 }).notNull().unique(), // '1hr', '5hr', '10hr'
    displayName: varchar('display_name', { length: 100 }).notNull(),
    displayNameUz: varchar('display_name_uz', { length: 100 }),
    priceUzs: integer('price_uzs').notNull(),
    minutes: integer('minutes').notNull(),
    description: text('description'),
    descriptionUz: text('description_uz'),
    isActive: boolean('is_active').default(true).notNull(),
    sortOrder: integer('sort_order').default(0).notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => ({
    nameIdx: uniqueIndex('minute_packages_name_idx').on(table.name),
    activeIdx: index('minute_packages_active_idx').on(table.isActive),
  })
);

// ============================================
// USER SUBSCRIPTIONS
// ============================================
export const userSubscriptions = pgTable(
  'user_subscriptions',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' })
      .unique(), // One active subscription per user
    planId: uuid('plan_id')
      .notNull()
      .references(() => subscriptionPlans.id),

    // Billing cycle
    billingCycleStart: timestamp('billing_cycle_start', { withTimezone: true }).notNull(),
    billingCycleEnd: timestamp('billing_cycle_end', { withTimezone: true }).notNull(),

    // Minutes tracking
    minutesIncluded: integer('minutes_included').notNull(), // From plan
    minutesUsed: integer('minutes_used').default(0).notNull(), // Used this cycle

    // Bonus minutes from packages (don't reset on cycle)
    bonusMinutes: integer('bonus_minutes').default(0).notNull(),

    status: varchar('status', { length: 20 }).default('active').notNull(), // 'active', 'expired', 'cancelled'

    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => ({
    userIdx: uniqueIndex('user_subscriptions_user_idx').on(table.userId),
    statusIdx: index('user_subscriptions_status_idx').on(table.status),
    cycleEndIdx: index('user_subscriptions_cycle_end_idx').on(table.billingCycleEnd),
  })
);

export const userSubscriptionsRelations = relations(userSubscriptions, ({ one, many }) => ({
  user: one(users, {
    fields: [userSubscriptions.userId],
    references: [users.id],
  }),
  plan: one(subscriptionPlans, {
    fields: [userSubscriptions.planId],
    references: [subscriptionPlans.id],
  }),
  transactions: many(minuteTransactions),
}));

// ============================================
// MINUTE TRANSACTIONS (Usage & Purchase History)
// ============================================
export const minuteTransactions = pgTable(
  'minute_transactions',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    subscriptionId: uuid('subscription_id').references(() => userSubscriptions.id),
    lectureId: uuid('lecture_id').references(() => lectures.id, { onDelete: 'set null' }),
    packageId: uuid('package_id').references(() => minutePackages.id),

    // Transaction type
    type: varchar('type', { length: 30 }).notNull(),
    // Types: 'plan_activation', 'plan_renewal', 'package_purchase',
    //        'video_processing', 'refund', 'admin_adjustment', 'promo_credit'

    minutes: integer('minutes').notNull(), // Positive = credit, Negative = debit

    // For usage tracking
    videoDurationSeconds: integer('video_duration_seconds'),

    // Balance after transaction
    planMinutesAfter: integer('plan_minutes_after'),
    bonusMinutesAfter: integer('bonus_minutes_after'),

    description: text('description'),
    metadata: jsonb('metadata'),

    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => ({
    userIdx: index('minute_transactions_user_idx').on(table.userId),
    subscriptionIdx: index('minute_transactions_subscription_idx').on(table.subscriptionId),
    lectureIdx: index('minute_transactions_lecture_idx').on(table.lectureId),
    typeIdx: index('minute_transactions_type_idx').on(table.type),
    createdAtIdx: index('minute_transactions_created_at_idx').on(table.createdAt),
  })
);

export const minuteTransactionsRelations = relations(minuteTransactions, ({ one }) => ({
  user: one(users, {
    fields: [minuteTransactions.userId],
    references: [users.id],
  }),
  subscription: one(userSubscriptions, {
    fields: [minuteTransactions.subscriptionId],
    references: [userSubscriptions.id],
  }),
  lecture: one(lectures, {
    fields: [minuteTransactions.lectureId],
    references: [lectures.id],
  }),
  package: one(minutePackages, {
    fields: [minuteTransactions.packageId],
    references: [minutePackages.id],
  }),
}));

// ============================================
// PAYMENTS (for Payme.uz integration later)
// ============================================
export const payments = pgTable(
  'payments',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    userId: uuid('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),

    // What was purchased
    paymentType: varchar('payment_type', { length: 30 }).notNull(), // 'plan', 'package'
    planId: uuid('plan_id').references(() => subscriptionPlans.id),
    packageId: uuid('package_id').references(() => minutePackages.id),

    // Amount
    amountUzs: integer('amount_uzs').notNull(),

    // Payment provider details
    provider: varchar('provider', { length: 30 }).default('payme'), // 'payme', 'click', 'manual'
    providerTransactionId: varchar('provider_transaction_id', { length: 255 }),
    providerResponse: jsonb('provider_response'),

    // Status
    status: varchar('status', { length: 30 }).default('pending').notNull(), // 'pending', 'completed', 'failed', 'refunded'

    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    completedAt: timestamp('completed_at', { withTimezone: true }),
  },
  (table) => ({
    userIdx: index('payments_user_idx').on(table.userId),
    statusIdx: index('payments_status_idx').on(table.status),
    providerTxIdx: index('payments_provider_tx_idx').on(table.providerTransactionId),
  })
);

export const paymentsRelations = relations(payments, ({ one }) => ({
  user: one(users, {
    fields: [payments.userId],
    references: [users.id],
  }),
  plan: one(subscriptionPlans, {
    fields: [payments.planId],
    references: [subscriptionPlans.id],
  }),
  package: one(minutePackages, {
    fields: [payments.packageId],
    references: [minutePackages.id],
  }),
}));
